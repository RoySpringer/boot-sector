<!DOCTYPE html>
<html lang="nl">
  <meta charset="utf-8" />
  <title>Crypto Lock</title>
  <style>
    body {
      font-family: "Courier New", monospace;
      background: #0a0a0a;
      color: #00ff00;
      margin: 0;
      padding: 20px;
      line-height: 1.6;
    }
    .terminal {
      background: #000;
      border: 2px solid #00ff00;
      border-radius: 8px;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
    }
    .header {
      text-align: center;
      border-bottom: 1px solid #00ff00;
      padding-bottom: 10px;
      margin-bottom: 20px;
    }
    .crypto-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 1px;
      margin: 20px 0;
      background: #111;
      padding: 8px;
      border-radius: 4px;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
      position: relative;
    }
    .crypto-cell {
      background: #222;
      border: 1px solid #333;
      padding: 6px;
      text-align: center;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s;
      min-height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    .coordinate-label {
      position: absolute;
      font-size: 8px;
      color: #666;
      font-weight: bold;
    }
    .coordinate-label.row {
      left: -15px;
      top: 50%;
      transform: translateY(-50%);
    }
    .coordinate-label.col {
      top: -15px;
      left: 50%;
      transform: translateX(-50%);
    }
    .crypto-cell:hover .coordinate-label {
      color: #00ff00;
    }
    .crypto-cell:hover {
      background: #333;
      border-color: #00ff00;
    }
    .crypto-cell.revealed {
      background: #004400;
      border-color: #00ff00;
      color: #fff;
    }
    .crypto-cell.revealed.layer2 {
      background: #440000;
      border-color: #ff0000;
      color: #fff;
    }
    .input-section {
      margin: 20px 0;
    }
    .input-group {
      display: flex;
      gap: 10px;
      margin: 10px 0;
    }
    input[type="text"] {
      flex: 1;
      background: #111;
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 10px;
      font-family: "Courier New", monospace;
      border-radius: 4px;
    }
    input[type="text"]:focus {
      outline: none;
      border-color: #00aa00;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
    }
    button {
      background: #004400;
      color: #00ff00;
      border: 1px solid #00ff00;
      padding: 10px 20px;
      cursor: pointer;
      font-family: "Courier New", monospace;
      border-radius: 4px;
      transition: all 0.2s;
    }
    button:hover {
      background: #006600;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
    }
    .status {
      margin: 10px 0;
      padding: 10px;
      border-radius: 4px;
      font-weight: bold;
    }
    .status.success {
      background: #004400;
      border: 1px solid #00ff00;
    }
    .status.error {
      background: #440000;
      border: 1px solid #ff0000;
      color: #ff6666;
    }
    .status.info {
      background: #004444;
      border: 1px solid #00ffff;
      color: #00ffff;
    }
    .hint {
      background: #222;
      border-left: 3px solid #00ff00;
      padding: 10px;
      margin: 10px 0;
      font-size: 14px;
    }
    .ascii-art {
      font-family: monospace;
      white-space: pre;
      text-align: center;
      margin: 20px 0;
      color: #00aa00;
    }
    .progress-bar {
      width: 100%;
      height: 20px;
      background: #111;
      border: 1px solid #00ff00;
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #00ff00, #00aa00);
      width: 0%;
      transition: width 0.5s;
    }
    .progress-fill.layer2 {
      background: linear-gradient(90deg, #ff0000, #aa0000);
    }
    .hidden {
      display: none;
    }
    .cryptic-hint {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid #00ff00;
      padding: 10px;
      border-radius: 4px;
      font-size: 12px;
      color: #00ff00;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      max-width: 300px;
    }
    .cryptic-hint.show {
      opacity: 1;
    }
    .hint-trigger {
      cursor: help;
      border-bottom: 1px dotted #00ff00;
    }
    .matrix-rain {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -2;
      opacity: 0.05;
    }
    .matrix-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
      opacity: 0.1;
    }
    .matrix-char {
      position: absolute;
      color: #00ff00;
      font-size: 12px;
      animation: matrix-fall 3s linear infinite;
    }
    @keyframes matrix-fall {
      0% {
        transform: translateY(-100vh);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh);
        opacity: 0;
      }
    }
  </style>
  <body>
    <div class="matrix-bg" id="matrix-bg"></div>
    <div class="matrix-rain" id="matrix-rain"></div>

    <!-- Hidden cryptic elements -->
    <div class="cryptic-hint" id="cryptic-hint-1">
      <strong>üîç SECRET WHISPER:</strong><br />
      The first sequence follows the path of a bishop's journey
    </div>
    <!-- HINT 1: The first sequence follows the diagonal path of a bishop's journey -->

    <div class="terminal">
      <div class="header">
        <h1>üîê CRYPTO LOCK v2.0 üîê</h1>
        <p>Multi-layer encryption breach required</p>
      </div>

      <div class="ascii-art">
        <pre>
          ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
          ‚ïë                  QUANTUM ENCRYPTION MATRIX                   ‚ïë
          ‚ïë ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ïë
          ‚ïë ‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà ‚ïë
          ‚ïë ‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà ‚ïë
          ‚ïë ‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà ‚ïë
          ‚ïë ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ïë
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        </pre>
      </div>

      <div class="hint" id="current-hint">
        <strong>üîç INITIAL SCAN:</strong> Coordinates dance in sequence.
      </div>

      <div class="crypto-grid" id="crypto-grid"></div>

      <div class="progress-bar">
        <div class="progress-fill" id="progress-fill"></div>
      </div>

      <div class="input-section">
        <div class="input-group">
          <input
            type="text"
            id="layer1"
            placeholder="Enter the sequence you found..."
          />
          <button onclick="checkLayer1()">Check Sequence</button>
        </div>

        <div class="input-group hidden" id="layer2-group">
          <input
            type="text"
            id="layer2"
            placeholder="Enter the crypto word you found..."
          />
          <button onclick="checkLayer2()">Check Crypto Word</button>
        </div>

        <div class="input-group hidden" id="layer3-group">
          <input
            type="text"
            id="layer3"
            placeholder="Enter 'confirm' to finalize..."
          />
          <button onclick="checkLayer3()">Finalize Breach</button>
        </div>
      </div>

      <div id="status"></div>
      <div id="reveal" class="hidden">
        <div class="status success">
          <h3>üéâ ACCESS GRANTED! üéâ</h3>
          <p>Segment: <strong>CRYPTO</strong></p>
          <p>You've successfully breached the quantum encryption matrix!</p>
        </div>
      </div>
    </div>

    <script>
      // Matrix background effect
      function createMatrixEffect() {
        const bg = document.getElementById("matrix-bg");
        const chars =
          "01„Ç¢„Ç§„Ç¶„Ç®„Ç™„Ç´„Ç≠„ÇØ„Ç±„Ç≥„Çµ„Ç∑„Çπ„Çª„ÇΩ„Çø„ÉÅ„ÉÑ„ÉÜ„Éà„Éä„Éã„Éå„Éç„Éé„Éè„Éí„Éï„Éò„Éõ„Éû„Éü„É†„É°„É¢„É§„É¶„É®„É©„É™„É´„É¨„É≠„ÉØ„É≤„É≥";

        setInterval(() => {
          const char = document.createElement("div");
          char.className = "matrix-char";
          char.textContent = chars[Math.floor(Math.random() * chars.length)];
          char.style.left = Math.random() * 100 + "%";
          char.style.animationDelay = Math.random() * 3 + "s";
          bg.appendChild(char);

          setTimeout(() => char.remove(), 3000);
        }, 100);
      }

      // Matrix rain effect with hidden messages
      function createMatrixRain() {
        const rain = document.getElementById("matrix-rain");
        const messages = [
          "A1‚ÜíB2‚ÜíC3‚ÜíD4‚ÜíE5‚ÜíF6‚ÜíG7‚ÜíH8",
          "A+2=C, C-1=B, G-5=B, B+3=E",
          "C-R-Y-P-T-O-L-K",
          "CONFIRM",
          "DIAGONAL PATH",
          "TRANSFORMATION",
          "CRYPTO WORD",
        ];

        setInterval(() => {
          const message = document.createElement("div");
          message.style.position = "absolute";
          message.style.color = "#00ff00";
          message.style.fontSize = "10px";
          message.style.left = Math.random() * 100 + "%";
          message.style.top = "-20px";
          message.style.opacity = "0.3";
          message.style.pointerEvents = "none";
          message.textContent =
            messages[Math.floor(Math.random() * messages.length)];
          rain.appendChild(message);

          // Animate falling
          let pos = -20;
          const fall = setInterval(() => {
            pos += 1;
            message.style.top = pos + "px";
            if (pos > window.innerHeight) {
              clearInterval(fall);
              message.remove();
            }
          }, 50);
        }, 2000);
      }

      // Mouse hover hint system
      function setupMouseHints() {
        const hint1 = document.getElementById("cryptic-hint-1");
        const hint2 = document.getElementById("cryptic-hint-2");
        const hint3 = document.getElementById("cryptic-hint-3");
        let hintId;

        // Add hover triggers to specific elements
        const header = document.querySelector(".header h1");
        header.classList.add("hint-trigger");
        header.addEventListener("mouseenter", (e) => {
          hintId = setTimeout(() => {
            hint1.style.left = e.pageX + 10 + "px";
            hint1.style.top = e.pageY + 10 + "px";
            hint1.classList.add("show");
          }, 30000);
        });
        header.addEventListener("mouseleave", () => {
          clearTimeout(hintId);
          hint1.classList.remove("show");
        });

        const progressBar = document.querySelector(".progress-bar");
        progressBar.classList.add("hint-trigger");
        progressBar.addEventListener("mouseenter", (e) => {
          hint2.style.left = e.pageX + 10 + "px";
          hint2.style.top = e.pageY + 10 + "px";
          hint2.classList.add("show");
        });
        progressBar.addEventListener("mouseleave", () => {
          hint2.classList.remove("show");
        });

        const asciiArt = document.querySelector(".ascii-art");
        asciiArt.classList.add("hint-trigger");
        asciiArt.addEventListener("mouseenter", (e) => {
          hint3.style.left = e.pageX + 10 + "px";
          hint3.style.top = e.pageY + 10 + "px";
          hint3.classList.add("show");
        });
        asciiArt.addEventListener("mouseleave", () => {
          hint3.classList.remove("show");
        });
      }

      // CryptoGrid Class - handles grid creation, sequence placement, and checking
      class CryptoGrid {
        constructor(
          gridElementId,
          columns = ["A", "B", "C", "D", "E", "F", "G", "H"],
          rows = ["1", "2", "3", "4", "5", "6", "7", "8"]
        ) {
          this.gridElement = document.getElementById(gridElementId);
          this.columns = columns;
          this.rows = rows;
          this.gridData = {};
          this.targetSequence = [];
          this.targetCoords = [];
          this.placementType = "random"; // 'random' or 'coordinated'
          this.onProgressUpdate = null;
          this.onCellClick = null;
        }

        // Set the target sequence and placement type
        setTargetSequence(sequence, placementType = "random", coords = []) {
          this.targetSequence = sequence;
          this.placementType = placementType;
          this.targetCoords = coords;
        }

        // Generate random positions for the grid
        generateRandomPositions() {
          const positions = [];
          for (let i = 0; i < this.columns.length * this.rows.length; i++) {
            positions.push(i);
          }
          // Shuffle positions
          for (let i = positions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [positions[i], positions[j]] = [positions[j], positions[i]];
          }
          return positions;
        }

        // Generate random letter+number combination
        generateRandomValue(excludeValues = []) {
          let randomValue;
          do {
            const randomLetter = String.fromCharCode(
              65 + Math.floor(Math.random() * 26)
            );
            const randomNumber = Math.floor(Math.random() * 10);
            randomValue = randomLetter + randomNumber;
          } while (excludeValues.includes(randomValue));
          return randomValue;
        }

        // Create the grid data
        createGridData() {
          this.gridData = {};

          if (this.placementType === "random") {
            // Place sequence randomly in the grid
            const randomPositions = this.generateRandomPositions();

            for (let i = 0; i < this.targetSequence.length; i++) {
              const pos = randomPositions[i];
              const row = Math.floor(pos / this.columns.length);
              const col = pos % this.columns.length;
              const coord = this.columns[col] + this.rows[row];
              this.gridData[coord] = this.targetSequence[i];
            }
          } else if (this.placementType === "coordinated") {
            // Place sequence on specific coordinates
            for (let i = 0; i < this.targetSequence.length; i++) {
              const coord = this.targetCoords[i];
              this.gridData[coord] = this.targetSequence[i];
            }
          }

          // Fill remaining cells with random values
          for (let col = 0; col < this.columns.length; col++) {
            for (let row = 0; row < this.rows.length; row++) {
              const coord = this.columns[col] + this.rows[row];
              if (!this.gridData[coord]) {
                this.gridData[coord] = this.generateRandomValue(
                  this.targetSequence
                );
              }
            }
          }
        }

        // Render the grid to the DOM
        render() {
          this.gridElement.innerHTML = "";
          this.createGridData();

          // Add layer class to grid element for styling
          if (this.placementType === "coordinated") {
            this.gridElement.classList.add("layer2");
          } else {
            this.gridElement.classList.remove("layer2");
          }

          for (let row = 0; row < this.rows.length; row++) {
            for (let col = 0; col < this.columns.length; col++) {
              const coord = this.columns[col] + this.rows[row];
              const cell = this.createCell(coord, row, col);
              this.gridElement.appendChild(cell);
            }
          }
        }

        // Create a single cell
        createCell(coord, row, col) {
          const cell = document.createElement("div");
          const cellContent = document.createElement("div");
          cellContent.className = "cell-content";
          cellContent.textContent = "‚ñà‚ñà";
          cell.className = "crypto-cell";
          cell.appendChild(cellContent);
          cell.dataset.coord = coord;
          cell.dataset.value = this.gridData[coord];
          cell.dataset.row = row;
          cell.dataset.col = col;

          // Add coordinate labels
          if (col === 0) {
            const rowLabel = document.createElement("div");
            rowLabel.className = "coordinate-label row";
            rowLabel.textContent = this.rows[row];
            cell.appendChild(rowLabel);
          }
          if (row === 0) {
            const colLabel = document.createElement("div");
            colLabel.className = "coordinate-label col";
            colLabel.textContent = this.columns[col];
            cell.appendChild(colLabel);
          }

          // Add click event
          cell.addEventListener("click", () =>
            this.handleCellClick(cell, coord)
          );

          return cell;
        }

        // Handle cell click
        handleCellClick(cell, coord) {
          if (cell.classList.contains("revealed")) {
            // Close the tile
            cell.classList.remove("revealed");
            cell.querySelector(".cell-content").textContent = "‚ñà‚ñà";
            // Remove red background when closing
            cell.style.background = "";
            cell.style.borderColor = "";
          } else {
            // Open the tile
            cell.classList.add("revealed");
            cell.querySelector(".cell-content").textContent =
              this.gridData[coord];

            // Check if this is a correct click (target coordinate)
            const isCorrectClick = this.targetCoords.includes(coord);

            // Highlight target cells with different colors based on placement type
            if (this.placementType === "random") {
              if (this.targetSequence.includes(this.gridData[coord])) {
                // Layer 1: Green theme for correct
                cell.style.background = "#006600";
                cell.style.borderColor = "#00ff00";
              }
            } else if (this.placementType === "coordinated") {
              // Layer 2: Check if this is a correct coordinate
              if (isCorrectClick) {
                // Correct click: Red theme
                cell.style.background = "#006600";
                cell.style.borderColor = "#00ff00";
              } else {
                // Wrong click: Bright red background
                cell.style.background = "#ff0000";
                cell.style.borderColor = "#ff6666";

                // Only count wrong clicks for layer 2
                layer2ClickCount++;

                // Check if max wrong clicks reached
                if (layer2ClickCount > MAX_LAYER2_CLICKS) {
                  showStatus(
                    `Maximum wrong clicks (${MAX_LAYER2_CLICKS}) reached! Refreshing page...`,
                    "error"
                  );
                  setTimeout(() => {
                    window.location.reload();
                  }, 2000);
                  return;
                }

                // Show remaining clicks
                const remainingClicks = MAX_LAYER2_CLICKS - layer2ClickCount;
                showStatus(
                  `Layer 2: ${remainingClicks} wrong clicks remaining`,
                  "info"
                );
              }
            }
          }

          // Call custom click handler if provided
          if (this.onCellClick) {
            this.onCellClick(cell, coord);
          }

          // Update progress
          if (this.onProgressUpdate) {
            this.onProgressUpdate();
          }
        }

        // Check if the target sequence is found
        isSequenceFound() {
          if (this.placementType === "random") {
            // Check if all target values are revealed AND no extra cells are revealed
            const revealedCells = document.querySelectorAll(
              ".crypto-cell.revealed"
            );
            const revealedValues = Array.from(revealedCells).map(
              (cell) => cell.dataset.value
            );

            // Check if all target values are revealed
            const allTargetsRevealed = this.targetSequence.every((value) =>
              revealedValues.includes(value)
            );

            // Check if no extra cells are revealed (exactly the right number)
            const noExtraCells =
              revealedValues.length === this.targetSequence.length;

            return allTargetsRevealed && noExtraCells;
          } else if (this.placementType === "coordinated") {
            // Check if all target coordinates are revealed AND no extra cells are revealed
            const revealedCells = document.querySelectorAll(
              ".crypto-cell.revealed"
            );
            const revealedCoords = Array.from(revealedCells).map(
              (cell) => cell.dataset.coord
            );

            // Check if all target coordinates are revealed
            const allTargetsRevealed = this.targetCoords.every((coord) =>
              revealedCoords.includes(coord)
            );

            // Check if no extra cells are revealed (exactly the right number)
            const noExtraCells =
              revealedCoords.length === this.targetCoords.length;

            return allTargetsRevealed && noExtraCells;
          }
          return false;
        }

        // Get revealed target values
        getRevealedTargetValues() {
          if (this.placementType === "random") {
            return this.targetSequence.filter((value) => {
              const cells = document.querySelectorAll(".crypto-cell.revealed");
              return Array.from(cells).some(
                (cell) => cell.dataset.value === value
              );
            });
          } else if (this.placementType === "coordinated") {
            return this.targetCoords.filter((coord) => {
              const cell = document.querySelector(`[data-coord="${coord}"]`);
              return cell && cell.classList.contains("revealed");
            });
          }
          return [];
        }

        // Get progress percentage
        getProgressPercentage() {
          const revealed = this.getRevealedTargetValues();
          return Math.floor(
            (revealed.length / this.targetSequence.length) * 100
          );
        }

        // Clear the grid
        clear() {
          this.gridElement.innerHTML = "";
          this.gridData = {};
        }
      }

      // Global grid instances
      let layer1Grid = null;
      let layer2Grid = null;
      let layer2ClickCount = 0; // Track clicks for layer 2
      const MAX_LAYER2_CLICKS = 8; // Maximum clicks allowed for layer 2

      // Initialize the crypto grid - now using the CryptoGrid class
      function initCryptoGrid(gridType = "layer1") {
        if (gridType === "layer1") {
          // Initialize layer 1 grid
          layer1Grid = new CryptoGrid("crypto-grid");

          // Set up layer 1 data
          const sequentialPattern = [
            "A1",
            "B2",
            "C3",
            "D4",
            "E5",
            "F6",
            "G7",
            "H8",
          ];
          const transformationHints = [
            "A+2",
            "C-1",
            "G-5",
            "B+3",
            "E+3",
            "F-2",
            "H",
            "D-3",
          ];
          const transformedCoords = [
            "A3",
            "C2",
            "G2",
            "B5",
            "E8",
            "F4",
            "H8",
            "D1",
          ];
          const cryptoWithNumbers = [
            "C8",
            "R10",
            "Y3",
            "P7",
            "T12",
            "O5",
            "L9",
            "K4",
          ];

          // Store data globally
          window.sequentialPattern = sequentialPattern;
          window.transformationHints = transformationHints;
          window.transformedCoords = transformedCoords;
          window.cryptoWithNumbers = cryptoWithNumbers;

          // Configure layer 1 grid
          layer1Grid.setTargetSequence(sequentialPattern, "random");
          layer1Grid.onProgressUpdate = updateProgress;
          layer1Grid.render();
        } else if (gridType === "layer2") {
          // Initialize layer 2 grid
          layer2Grid = new CryptoGrid("crypto-grid");

          // Configure layer 2 grid
          layer2Grid.setTargetSequence(
            window.cryptoWithNumbers,
            "coordinated",
            window.transformedCoords
          );
          layer2Grid.onProgressUpdate = updateCryptoProgress;
          layer2Grid.render();
        }
      }

      // Function to switch to the second grid (crypto word grid) - now simplified
      function switchToCryptoGrid() {
        // Reset click counter for layer 2
        layer2ClickCount = 0;

        initCryptoGrid("layer2");
        showStatus(
          "Crypto grid loaded! Find the hidden word using the transformation hints. You have 8 wrong clicks remaining.",
          "success"
        );
        document.getElementById("layer2-group").classList.remove("hidden");
      }

      // Function to update progress for crypto grid
      function updateCryptoProgress() {
        if (layer2Grid) {
          const progress = layer2Grid.getProgressPercentage();
          const progressFill = document.getElementById("progress-fill");
          progressFill.style.width = progress + "%";
          progressFill.classList.add("layer2"); // Add red theme

          if (layer2Grid.isSequenceFound()) {
            updateHint(4);
          }
        }
      }

      function updateProgress() {
        if (layer1Grid) {
          let progress = 0;

          // Step 1: Check for sequential pattern (A1, B2, C3, D4, E5, F6, G7, H8)
          const revealedSequential = layer1Grid.getRevealedTargetValues();

          // Debug: Log what's found
          console.log("Sequential pattern found:", revealedSequential);
          console.log(
            "All revealed values:",
            Array.from(document.querySelectorAll(".crypto-cell.revealed")).map(
              (cell) => cell.dataset.value
            )
          );

          // Step 1 progress: 0-8 correct sequential values = 0-33% progress
          progress = Math.floor((revealedSequential.length / 8) * 33);

          if (revealedSequential.length === 8) {
            if (!document.querySelector('[data-progress="step1"]')) {
              updateHint(2);
              document
                .querySelector(".crypto-grid")
                .setAttribute("data-progress", "step1");
            }
          }

          // Step 2: Check for transformation pattern (only if step 1 is complete)
          if (revealedSequential.length === 8) {
            const revealedTransformed = window.transformedCoords.filter(
              (coord) => {
                const cell = document.querySelector(`[data-coord="${coord}"]`);
                return cell && cell.classList.contains("revealed");
              }
            );

            if (revealedTransformed.length === 8) {
              progress = 66;
              if (!document.querySelector('[data-progress="step2"]')) {
                updateHint(3);
                document
                  .querySelector(".crypto-grid")
                  .setAttribute("data-progress", "step2");
              }
            } else {
              progress = 33; // Step 1 complete but transformation not yet found
            }
          }

          const progressFill = document.getElementById("progress-fill");
          progressFill.style.width = progress + "%";
          progressFill.classList.remove("layer2"); // Remove red theme for layer 1
        }
      }

      function updateHint(layer) {
        const hintElement = document.getElementById("current-hint");
        const hints = {
          1: "<strong>üîç INITIAL SCAN:</strong> Coordinates dance in sequence.",
          2: "<strong>‚ÄºÔ∏è PATTERN DETECTED:</strong> The sequence is complete. Going is high alert mode. Limited clicks are activated. Now the grid speaks in transformations. Only A real inspector can solve this.",
          3: "<strong>TRANSFORMATION COMPLETE:</strong> System is compromised.",
          4: "<strong>FINAL DECRYPTION:</strong> The crypto word is complete. Enter it to finalize the breach sequence.",
        };

        if (hints[layer]) {
          hintElement.innerHTML = hints[layer];
        }
      }

      function checkLayer1() {
        const input = document
          .getElementById("layer1")
          .value.trim()
          .toUpperCase();

        // Check if the sequential pattern is found using the grid class
        if (
          layer1Grid &&
          layer1Grid.isSequenceFound() &&
          input.replace(/,/g, "").replace(/ /g, "") === "A1B2C3D4E5F6G7H8"
        ) {
          showStatus(
            "Sequential pattern discovered! Switching to crypto grid...",
            "success"
          );

          // Switch to the crypto grid
          setTimeout(() => {
            switchToCryptoGrid();
            showStatus(
              "Crypto grid loaded! Second encryption layer activated.",
              "success"
            );
            document.getElementById("layer2-group").classList.remove("hidden");
          }, 2000);
        } else {
          showStatus("Incorrect pattern. Try again.", "error");
        }
      }

      function checkLayer2() {
        const input = document
          .getElementById("layer2")
          .value.trim()
          .toLowerCase();

        // Check if the crypto word is found using the grid class
        if (layer2Grid && layer2Grid.isSequenceFound()) {
          // The expected answer is the letters from the crypto word: "cryptolk"
          const expected = "cryptolk";

          if (input === expected) {
            showStatus(
              "Crypto word discovered! You've successfully breached the system!",
              "success"
            );
            document.getElementById("layer3-group").classList.remove("hidden");
          } else {
            showStatus("Incorrect. Try again.", "error");
          }
        } else {
          showStatus("Incorrect. Try again.", "error");
        }
      }

      function checkLayer3() {
        const input = document
          .getElementById("layer3")
          .value.trim()
          .toLowerCase();

        // Final confirmation - any confirmation word
        const expected = "confirm";

        if (input === expected) {
          showStatus("üéâ All layers breached! Access granted!", "success");
          document.getElementById("reveal").classList.remove("hidden");
        } else {
          throw new Error("Confirmation word is is not matching `confirm`.");
          showStatus("Incorrect.", "error");
        }
      }

      function showStatus(message, type) {
        const status = document.getElementById("status");
        status.textContent = message;
        status.className = `status ${type}`;
      }

      // Initialize everything
      document.addEventListener("DOMContentLoaded", () => {
        createMatrixEffect();
        initCryptoGrid(); // Default to layer1

        // Allow Enter key to submit
        document.getElementById("layer1").addEventListener("keypress", (e) => {
          if (e.key === "Enter") checkLayer1();
        });
        document.getElementById("layer2").addEventListener("keypress", (e) => {
          if (e.key === "Enter") checkLayer2();
        });
        document.getElementById("layer3").addEventListener("keypress", (e) => {
          if (e.key === "Enter") checkLayer3();
        });

        // Add cryptic console hints
        console.log(
          "%cüîê CRYPTO LOCK DEBUG MODE üîê",
          "color: #00ff00; font-size: 20px; font-weight: bold;"
        );
        console.log(
          "%cType 'help()' in console for cryptic assistance",
          "color: #00aa00; font-size: 14px;"
        );

        // Add global help function for console hints
        window.help = function () {
          console.log(
            "%c=== CRYPTIC ASSISTANCE ===",
            "color: #00ff00; font-weight: bold;"
          );
          console.log(
            "%cLayer 1: Which numbers make the progression?",
            "color: #00aa00;"
          );
          console.log(
            "%cLayer 2: Mathematical transformations reveal new coordinates",
            "color: #00aa00;"
          );
          console.log(
            "%cLayer 3: #*(DJAHS*((!@JKLS)!*#DH*(())))",
            "color: #00aa00;"
          );
          console.log(
            "%cType 'hint(1)', 'hint(2)', or 'hint(3)' for specific guidance",
            "color: #00aa00;"
          );
        };

        window.hint = function (layer) {
          if (layer === 3)
            throw new Error("numbers are not allowed. remove them.");
          const hints = {
            1: "Find each number in the sequence by clicking on the grid",
            2: `Transform coordinates: ${window.transformationHints.map(
              (hint) => `${hint}`
            )}`,
          };
          console.log(
            "%c" + hints[layer],
            "color: #ffaa00; font-weight: bold;"
          );
        };

        // Add keyboard shortcuts for cryptic hints
        document.addEventListener("keydown", (e) => {
          // Ctrl+Shift+H for hidden hint
          if (e.ctrlKey && e.shiftKey && e.key === "H") {
            e.preventDefault();
            showCrypticHint();
          }
          // Ctrl+Shift+D for debug mode
          if (e.ctrlKey && e.shiftKey && e.key === "D") {
            e.preventDefault();
            toggleDebugMode();
          }
          // Ctrl+Shift+M for matrix rain toggle
          if (e.ctrlKey && e.shiftKey && e.key === "M") {
            e.preventDefault();
            toggleMatrixRain();
          }
          // Secret combination: Ctrl+Alt+Shift+H for all hints
          if (e.ctrlKey && e.altKey && e.shiftKey && e.key === "H") {
            e.preventDefault();
            revealAllHints();
          }
        });

        // Initialize cryptic hint systems
        createMatrixRain();
        setupMouseHints();
      });

      // Function to show cryptic hint
      function showCrypticHint() {
        const currentLayer = getCurrentLayer();
        if (currentLayer != 1) return;
        const crypticHints = {
          1: "The grid whispers: 'A...B...C...D...E...F...G...H...'",
        };

        const hintElement = document.getElementById("current-hint");
        hintElement.innerHTML =
          "<strong>üîç CRYPTIC WHISPER:</strong> " + crypticHints[currentLayer];

        // Auto-hide after 5 seconds
        setTimeout(() => {
          updateHint(currentLayer);
        }, 5000);
      }

      // Function to get current layer
      function getCurrentLayer() {
        if (
          layer2Grid &&
          document
            .getElementById("layer2-group")
            .classList.contains("hidden") === false
        ) {
          return 2;
        } else if (layer1Grid) {
          return 1;
        }
        return 1;
      }

      // Function to toggle debug mode
      function toggleDebugMode() {
        const cells = document.querySelectorAll(".crypto-cell");
        cells.forEach((cell) => {
          if (cell.style.border === "2px solid red") {
            cell.style.border = "";
          } else {
            cell.style.border = "2px solid red";
          }
        });
        console.log(
          "%cDebug mode toggled - target cells highlighted",
          "color: #ff0000; font-weight: bold;"
        );
      }

      // Function to toggle matrix rain
      function toggleMatrixRain() {
        const rain = document.getElementById("matrix-rain");
        if (rain.style.display === "none") {
          rain.style.display = "block";
          console.log(
            "%cMatrix rain enabled - look for hidden messages",
            "color: #00ff00; font-weight: bold;"
          );
        } else {
          rain.style.display = "none";
          console.log(
            "%cMatrix rain disabled",
            "color: #ff0000; font-weight: bold;"
          );
        }
      }

      // Function to reveal all hints (secret combination)
      function revealAllHints() {
        console.log(
          "%c=== ALL HINTS REVEALED ===",
          "color: #ff0000; font-size: 16px; font-weight: bold;"
        );
        console.log(
          "%cLayer 1: Click A1, B2, C3, D4, E5, F6, G7, H8 in sequence",
          "color: #ffaa00; font-weight: bold;"
        );
        console.log(
          "%cLayer 2: Transform coordinates and click: A3, C2, G2, B5, E8, F4, H8, D1",
          "color: #ffaa00; font-weight: bold;"
        );
        console.log(
          "%cLayer 3: The crypto word is 'cryptolk'",
          "color: #ffaa00; font-weight: bold;"
        );
        console.log(
          "%cFinal: Enter 'confirm' to complete",
          "color: #ffaa00; font-weight: bold;"
        );

        // Show all cryptic hints at once
        const hints = document.querySelectorAll(".cryptic-hint");
        hints.forEach((hint) => {
          hint.style.opacity = "1";
          hint.style.position = "fixed";
          hint.style.top = "50%";
          hint.style.left = "50%";
          hint.style.transform = "translate(-50%, -50%)";
          hint.style.zIndex = "9999";
          hint.style.background = "rgba(0, 0, 0, 0.95)";
          hint.style.border = "2px solid #ff0000";
          hint.style.fontSize = "16px";
          hint.style.padding = "20px";
        });

        // Auto-hide after 10 seconds
        setTimeout(() => {
          hints.forEach((hint) => {
            hint.style.opacity = "0";
            hint.style.position = "absolute";
            hint.style.top = "-9999px";
            hint.style.left = "-9999px";
          });
        }, 10000);
      }
    </script>
  </body>
</html>
